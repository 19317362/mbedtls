/* BEGIN_HEADER */
#include <stdint.h>

#include "common.h"

#include "psa/crypto.h"

#include "psa_crypto_core.h"

#include "test/psa_crypto_helpers.h"

/* Helper to fill a buffer with a data pattern. The pattern is not
 * important, it just allows a basic check that the correct thing has
 * been written, in a way that will detect an error in offset. */
static void fill_buffer_pattern(uint8_t *buffer, size_t len)
{
    uint8_t data[] = { 0x12, 0x34, 0x56, 0x78 };

    for (size_t i = 0; i < len; i++) {
        buffer[i] = data[i % sizeof(data)];
    }
}
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PSA_CRYPTO_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void copy_input(int src_len, int dst_len, psa_status_t exp_status)
{
    uint8_t *src_buffer = NULL;
    uint8_t *dst_buffer = NULL;
    psa_status_t status;

    TEST_CALLOC_NONNULL(src_buffer, src_len);
    TEST_CALLOC_NONNULL(dst_buffer, dst_len);

    fill_buffer_pattern(src_buffer, src_len);

    status = psa_crypto_copy_input(src_buffer, src_len, dst_buffer, dst_len);
    TEST_EQUAL(status, exp_status);

    if (exp_status == PSA_SUCCESS) {
        /* Note: We compare the first src_len bytes of each buffer, as this is what was copied. */
        TEST_MEMORY_COMPARE(src_buffer, src_len, dst_buffer, src_len);
    }

exit:
    mbedtls_free(src_buffer);
    mbedtls_free(dst_buffer);
}
/* END_CASE */

/* BEGIN_CASE */
void copy_output(int src_len, int dst_len, psa_status_t exp_status)
{
    uint8_t *src_buffer = NULL;
    uint8_t *dst_buffer = NULL;
    psa_status_t status;

    TEST_CALLOC_NONNULL(src_buffer, src_len);
    TEST_CALLOC_NONNULL(dst_buffer, dst_len);

    fill_buffer_pattern(src_buffer, src_len);

    status = psa_crypto_copy_output(src_buffer, src_len, dst_buffer, dst_len);
    TEST_EQUAL(status, exp_status);

    if (exp_status == PSA_SUCCESS) {
        /* Note: We compare the first src_len bytes of each buffer, as this is what was copied. */
        TEST_MEMORY_COMPARE(src_buffer, src_len, dst_buffer, src_len);
    }

exit:
    mbedtls_free(src_buffer);
    mbedtls_free(dst_buffer);
}
/* END_CASE */

/* BEGIN_CASE */
void input_copy_alloc(int input_len, psa_status_t exp_status)
{
    uint8_t *input = NULL;
    psa_crypto_input_copy_t input_copy;
    psa_status_t status;

    input_copy.buffer = NULL;

    TEST_CALLOC(input, input_len);
    fill_buffer_pattern(input, input_len);

    status = psa_crypto_input_copy_alloc(input, input_len, &input_copy);
    TEST_EQUAL(status, exp_status);

    if (exp_status == PSA_SUCCESS) {
        if (input == NULL) {
            TEST_ASSERT(input_copy.buffer == NULL);
        } else {
            TEST_ASSERT(input_copy.buffer != input);
            TEST_MEMORY_COMPARE(input, input_len,
                                input_copy.buffer, input_copy.len);
        }
    }

exit:
    mbedtls_free(input_copy.buffer);
    mbedtls_free(input);
}
/* END_CASE */

/* BEGIN_CASE */
void input_copy_free(int input_len)
{
    psa_crypto_input_copy_t input_copy;

    input_copy.buffer = NULL;
    input_copy.len = input_len;
    TEST_CALLOC(input_copy.buffer, input_copy.len);

    psa_crypto_input_copy_free(&input_copy);

    TEST_ASSERT(input_copy.buffer == NULL);
    TEST_EQUAL(input_copy.len, 0);

exit:
    mbedtls_free(input_copy.buffer);
    input_copy.buffer = NULL;
    input_copy.len = 0;
}
/* END_CASE */

/* BEGIN_CASE */
void input_copy_round_trip()
{
    psa_crypto_input_copy_t input_copy;
    uint8_t input[200];
    psa_status_t status;

    fill_buffer_pattern(input, sizeof(input));

    status = psa_crypto_input_copy_alloc(input, sizeof(input), &input_copy);
    TEST_EQUAL(status, PSA_SUCCESS);
    TEST_MEMORY_COMPARE(input_copy.buffer, input_copy.len,
                        input, sizeof(input));
    TEST_ASSERT(input_copy.buffer != input);

    psa_crypto_input_copy_free(&input_copy);
    TEST_ASSERT(input_copy.buffer == NULL);
    TEST_EQUAL(input_copy.len, 0);
}
/* END_CASE */

/* BEGIN_CASE */
void output_copy_alloc(int output_len, psa_status_t exp_status)
{
    uint8_t *output = NULL;
    psa_crypto_output_copy_t output_copy;
    psa_status_t status;

    output_copy.buffer = NULL;

    TEST_CALLOC(output, output_len);

    status = psa_crypto_output_copy_alloc(output, output_len, &output_copy);
    TEST_EQUAL(status, exp_status);

    if (exp_status == PSA_SUCCESS) {
        TEST_ASSERT(output_copy.original == output);
        if (output == NULL) {
            TEST_ASSERT(output_copy.buffer == NULL);
        } else {
            TEST_EQUAL(output_copy.len, output_len);
        }
    }

exit:
    mbedtls_free(output_copy.buffer);
    output_copy.original = NULL;
    output_copy.buffer = NULL;
    output_copy.len = 0;
    mbedtls_free(output);
    output = NULL;
}
/* END_CASE */

/* BEGIN_CASE */
void output_copy_free(int output_len, int original_is_null,
                      psa_status_t exp_status)
{
    uint8_t *output = NULL;
    uint8_t *buffer_copy_for_comparison = NULL;
    psa_crypto_output_copy_t output_copy;
    psa_status_t status;

    output_copy.buffer = NULL;
    output_copy.len = 0;

    if (!original_is_null) {
        TEST_CALLOC(output, output_len);
    }
    TEST_CALLOC(buffer_copy_for_comparison, output_len);
    TEST_CALLOC(output_copy.buffer, output_len);
    output_copy.len = output_len;
    output_copy.original = output;

    if (output_copy.buffer != NULL) {
        fill_buffer_pattern(output_copy.buffer, output_copy.len);
        memcpy(buffer_copy_for_comparison, output_copy.buffer, output_copy.len);
    }

    status = psa_crypto_output_copy_free(&output_copy);
    TEST_EQUAL(status, exp_status);

    if (exp_status == PSA_SUCCESS) {
        TEST_ASSERT(output_copy.buffer == NULL);
        TEST_EQUAL(output_copy.len, 0);
        if (output != NULL) {
            TEST_MEMORY_COMPARE(buffer_copy_for_comparison, output_len,
                                output, output_len);
        }
    }

exit:
    mbedtls_free(output);
    mbedtls_free(buffer_copy_for_comparison);
    mbedtls_free(output_copy.buffer);
    output_copy.len = 0;
}
/* END_CASE */
